# Лаборатоные работы по предмету "Технологии нагруженных систем обработки данных"

## Лабораторная работа 1.

Цель работы - написать UserService. Это доменный сервис, который будет выполнять CRUD операции с пользователями. 

Сущность User должна иметь следующую структуру:
{
    id: int,
    login: string,
    password: string,
    name: string,
    surname: string,
    age: int
}

Должны быть реализованы методы в формате gRPC:
Создания пользователя - v1.0/users/create. Должна быть проверка уникальности пользователя по логину.
Получения пользователя по id - v1.0/users/getById.
Получения пользователя по имени и фамилии - v1.0/users/getByName.
Обновления данных пользователя(все кроме id и логина) - v1.0/users/update.
Удаление пользователя по id - v1.0/users/delete.

СУБД для данного сервиса - PostgreSQL.
Продумать структуру индексов, подходящую под запросы. Для каждого метода должна быть написана отдельная функция или процедура. Создание таблиц, индексов, процедур и функций должно быть вынесено в отдельные sql скрипты, которые должны располагаться в .sql файлах в папке Database. В рамках репозитория вы должны вызывать функции/процедуры по названию.

Вызов процедур и маппинг ответов БД в объекты должен осуществляться с помощью библиотеки Dapper. При работе с Dapper используйте DynamicParameters для того чтобы передавать аргументы функций/процедур. Из репозиториев стоит возвращать не IEnumerable, а отождествленную коллекцию(массив).

Для валидаций рекомендуется использовать библиотеку FluentValidation.

## Лабораторная работа 2.

Цель работы - написать сервис Writer, который будет выполнять CRUD операции с ограничениями по количеству запросов в минуту(Rate limiting for RPM) для методов UserService.

Сущность RateLimit должна иметь следующую структуру:
{
    route: string,
    requests_per_minute: int
}

Должны быть реализованы методы в формате gRPC:
Создание ограничения - v1.0/rate-limits/create. Должна быть проверка уникальности по route.
Получения ограничения по роуту - v1.0/rate-limits/get.
Обновление ограничения - v1.0/rate-limits/update.
Удаление ограничения v1.0/rate-limits/delete.

БД для данного сервиса - MongoDB. В БД должна быть одна коллекция - rate_limits.

Запросы и маппинг ответов БД в модели сервисов должны быть реализованы с помощью библиотеки MongoDb.Driver.

Не забудьте про CancellationToken’ы и три уровня моделей(Request/Response, Domain, DbModel)


## Лабораторная работа 3.

Цель работы - написать первую часть сервиса Reader. При старте сервиса выгружать ограничения из коллекции rate_limits в память сервиса батчами по 1000 элементов. Реализовать механизм обновления ограничений по RPM в памяти через механизм подписок на изменения MongoDB - collection.WatchAsync() для коллекции rate_limits.

Если ограничение обновляется, считаем, что новое значение сработает только в момент получения нового запроса по роуту от пользователя, для которого было изменено ограничение.
У потока, который обновляет ограничения единственная задача - обновление ограничений. Ограничения должны обновляться без специально сделанных пауз, и превышение лимитов должно проверяться при получении событий о том, что был выполнен запрос. При обновлении ограничений в меньшую сторону не нужно проверять, превышен ли лимит по пользователям. 

Сделать метод получения всех ограничений, которые на данный момент загружены в память сервиса v1.0/rate-limits/get. Метод должен иметь формат gRPC.

CancellationToken’ы здесь вам не понадобятся, как и модели запросов/ответов, поскольку не подразумевается, что у сервиса будут клиенты(метод получения ограничений из памяти может понадобиться только для дебага). Но модели уровней Domain, DbModel пожалуйста используйте. В сервисе нужно хранить ограничения в потокобезопасной коллекции. Изменения и батчи нужно получать в сервисе через IAsyncEnumerable. Обработка событий из монги должна осуществляться в отдельном потоке. Для загрузки батчами данных из БД и старта обработки событий необходимо сделать отдельный метод в сервисе и запускать его в IHostedService.

## Лабораторная работа 4.

Необходимо развернуть кафку в докере.

После этого нужно реализовать скрипт на языке C#, который будет отправлять сообщения в кафку. Для работы с кафкой используйте библиотеку Confluent.Kafka.

Скрипт должен настраиваться и уметь отправлять в Kafka события одновременно для нескольких пользователей, различных эндпойнтов и с разной частотой. Должна быть возможность отправлять разные запросы от одного пользователя. Конфигурация при этом должна быть динамическая – то есть в рамках работы скрипта должна быть возможность добавить отправку событий от лица нового пользователя во время работы скрипта или изменить RPM для уже отправляемых событий. 

Контракт события в кафке:
{
    user_id: int,
    endpoint: string
}

Поля в модели должны быть в snake_case!

Пример использования: для пользователя с id: 123 скрипт отправляет события совершения запросов к эндпойнту v1.0/users/getById с частотой 10 RPM, а для пользователя с id: 321 отправляет события совершения запросов к эндпойнту v1.0/users/getById с частотой 20RPM. Далее изменяется частота для второго задания на 25 RPM, а метод на v1.0/users/update.


## Лабораторная работа 5.

Цель работы - реализовать вторую часть функциональности сервиса Reader и получить полноценно работающий сервис. 

В кафку с помощью вашего скрипта из 4 лабораторной вы отправляете запросы, которые выполняются различными пользователями к методам UserService. Нужно подключиться к кафке в сервисе Reader, реализовать механизм отслеживания превышения RPM для конкретного метода и проставлять флаг в Redis о том, что лимит превышен – идентификатор того, что пользователю запрещено выполнять запросы. TTL запрета(флага в редисе) должен быть 5 минут. То есть если пользователь превысил допустимый лимит, необходимо запретить ему на 5 минут выполнять запросы. По прошествии пяти минут у него снова должна быть возможность их выполнять. Скорость исчерпания лимита пользователем значения не имеет для работы нашей системы.

Подключение и работа с Kafka должна выполняться с помощью Confluent.Kafka.



## Лабораторная работа 6.

Необходимо начать отправлять в запросах к UserService заголовок пользователя user_id: 123.

Реализовать Interceptor, который проверяет, что в заголовках содержится user_id. Если user_id не содержится, то запрос не должен попадать в сервис, а на клиент должно отправляться сообщение про необходимость аутентификации и проставления заголовка.

Реализовать Interceptor в UserService, который будет брать значение заголовка user_id и для конкретного пользователя проверять флаг в Redis, свидетельствующий о том, что превышен лимит для конкретного эндпойнта. Если лимит превышен, сервис должен возвращать ответ с информацией о том, что превышено разрешенное количество запросов в минуту к эндпойнту.


## Лабораторная работа 7.

В рамках UserService необходимо реализовать кеш в памяти для моделей пользователей, которые получаются из БД с помощью Get методов. Кеш должен быть реализован с помощю абстракции IMemoryCache. 

Помимо этого необходимо внедрить подход с интерфейсами вместо доменных моделей, который рассмотрен на 12 лекции. Добавьте необходимые доменные интефейсы. Теперь ваш доменный сервис должен работать только с доменными интерфейсами – и принимать интерфейсы и возвращать интерфейсы. 

Модели запросов нужно расширить через дополнительные partial классы, которые вы разместите в своем проекте и они будут реализовывать ваш доменный интерфейс. Обратите внимание, что namespace для нового partial класса должен быть такой же, как у класса запроса, который вы расширяете.

Аналогично DbModel’и должны реализовывать доменные интерфейсы.
